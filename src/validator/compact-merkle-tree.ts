import { createHash } from 'node:crypto'
import { TrailLog } from './trail-log'

const pop8tab = [
	0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
]

// Source: https://github.com/polynetwork/poly/blob/v1.8.3/merkle/merkle_tree.go#L152
export class CompactMerkleTree {
  private _hashes: Buffer[]
  private _rootHash: Buffer | undefined = undefined
  private _treeSize = 0
  // private _minTree_h = 0

  public constructor(
    treeSize: number,
    hashes: Buffer[] = [],
    private readonly hashStore?: TrailLog
  ) {
    this._treeSize = treeSize
    this.update(treeSize, hashes)
  }

  public get hashes(): Buffer[] {
    return this._hashes
  }

  public get treeSize(): number {
    return this._treeSize
  }

  public root(): Buffer {
    if (typeof this._rootHash !== 'undefined') {
      return this._rootHash
    }

    if (this._hashes.length) {
      this._rootHash = this.hashFold(this.hashes)
    } else {
      this._rootHash = CompactMerkleTree.emptyHash()
    }

    return this._rootHash
  }

  public append(value: Buffer | string): Buffer[] {

    const v = (typeof value === 'string')
      ? Buffer.from(value, 'hex')
      : value

    const leaf = CompactMerkleTree.hash(v)

    return this.appendHash(leaf)
  }

  private appendHash(leaf: Buffer): Buffer[] {
    let size = this.hashes.length

    const auditPath = new Array<Buffer>(size)

    for (let i = 0; i < size; i++) {
      auditPath[size - i - 1] = this.hashes[i]
    }

    const storeHashes = [leaf]

    // this._minTree_h = 1

    for (let s = this._treeSize; s % 2 === 1; s >>= 1) {
      // this._minTree_h++
      leaf = this.hashChildren(this._hashes[size - 1], leaf)
      storeHashes.push(leaf)
      size--
    }

    if (typeof this.hashStore !== 'undefined') {
      for (const hash of storeHashes) {
        this.hashStore.append(hash)
      }
    }

    this._treeSize++
    this._hashes.splice(size)
    this._hashes.push(leaf)
    this._rootHash = undefined

    return auditPath
  }

  private hashFold(hashes: Buffer[]): Buffer {
    const l = hashes.length

    let accum: Buffer = hashes[l - 1]

    for (let i = l - 2; i >= 0; i--) {
      accum = this.hashChildren(hashes[i], accum)
    }

    return accum
  }

  private hashChildren(left: Buffer, right: Buffer): Buffer {
    return CompactMerkleTree.hash(Buffer.concat([left, right]))
  }

  private static hash(leaf: Buffer): Buffer {
    return createHash('sha256').update(leaf).digest()
  }

  private update(treeSize: number, hashes: Buffer[]) {
    const numBit = CompactMerkleTree.onesCount32(treeSize)
    if (hashes.length !== numBit) {
      throw new Error('number of hashes != number of set bits in treeSize')
    }

    this._treeSize = treeSize
    this._hashes = hashes
    // this._minTree_h = CompactMerkleTree.length32(treeSize & -treeSize)
    this._rootHash = undefined
  }

  private static onesCount32(x: number): number {
    return pop8tab[x>>24] + pop8tab[x>>16&0xff] + pop8tab[x>>8&0xff] + pop8tab[x&0xff]
  }

  // private static length32(x: number): number {
  //   let n = 0
  //   if (x >= (1<<16)) {
  //     x >>= 16
  //     n = 16
  //   }
  //   if (x >= (1<<8)) {
  //     x >>= 8
  //     n += 8
  //   }
  //   return n + len8tab.charCodeAt(x)
  // }

  private static emptyHash(): Buffer {
    return CompactMerkleTree.hash(Buffer.from([]))
  }
}